import numpy as np
from numpy.polynomial import legendre
from numpy.polynomial import chebyshev
from abc import ABC, abstractmethod


class AbstractBasis(ABC):
    @abstractmethod
    def evaluate_basis(self, x: np.ndarray) -> np.ndarray:
        """
        Evaluate the value of basis for a given x
        :param x: ndarray like, points to be evaluated
        :return: ndarray like, shape = (len(x), num_basis), values at x for each basis
        """
        pass

    @abstractmethod
    def dim_basis(self) -> int:
        """
        :return: the dimension of the basis
        """
        pass

    @abstractmethod
    def HBasis(self, x: np.ndarray) -> np.ndarray:
        """
        :return: ndarray like, gives the orthogonal basis values
        """
        pass


class FourierBasis(AbstractBasis):
    """
    One dimensional Fourier basis
    - sin(k * 2pi * x) or cos(k * 2pi * x), k=1, ..., order (dim = order)
    - or sin + cos combined (k=1, ..., order), 2*order in total (dim = 2*order)
    """

    def __init__(self, order, kind='cos'):
        self.order = order
        self.kind = kind

        # Decide the number of basis according to param kind
        if self.kind == 'sin+cos':
            self._dim_basis = 2 * self.order  # (sin, cos) each order

        elif self.kind in ['sin', 'cos']:
            self._dim_basis = self.order

        else:
            raise ValueError(f"Invalid kind: {kind}")


    def evaluate_basis(self, x):
        """
        Evaluate the value of basis for a given x
        """
        x = np.array(x, ndmin=1)
        n_points = x.shape[0]

        B = np.zeros((n_points, self._dim_basis))

        if self.kind == 'sin+cos':
            idx = 0
            for k in range(1, self.order + 1):
                B[:, idx] = np.sin(2 * np.pi * k * x)
                B[:, idx + 1] = np.cos(2 * np.pi * k * x)
                idx += 2

        elif self.kind == 'sin':
            for k in range(1, self.order + 1):
                B[:, k - 1] = np.sin(np.pi * k * x)
        elif self.kind == 'cos':
            for k in range(1, self.order + 1):
                B[:, k - 1] = np.cos(np.pi * k * x)

        return B


    def dim_basis(self):
        return self._dim_basis


    def HBasis(self, x: np.ndarray) -> np.ndarray:
        """
        This function does similar with self.evaluate_basis(x), but will
        return orthogonal basis values.
        """
        return np.sqrt(2) * self.evaluate_basis(x)


class LegendreBasis(AbstractBasis):
    """
    One dimensional Legendre basis
    - [P_0(x), P_1(x), ..., P_order(x)]
    - Can be generated by Rodrigues' formula:
        P_n(x) = \frac{\diff{(x^2 - 1)^n}{n}}{2^n * n!}
    Note that x should be within interval [-1, 1]
    """

    def __init__(self, order):
        self.order = order
        # Legendre polynomial is from 0 to order, dim = order + 1
        self._dim_basis = order + 1

    def evaluate_basis(self, x: np.ndarray) -> np.ndarray:
        x = np.array(x, ndmin=1)
        n_points = x.shape[0]

        B = np.zeros((n_points, self._dim_basis))

        for i in range(self._dim_basis):
            c = np.zeros(i + 1)
            c[-1] = 1.0  # P_i(x)
            B[:, i] = legendre.legval(x, c)

        return B

    def dim_basis(self):
        return self._dim_basis

    def HBasis(self, x: np.ndarray) -> np.ndarray:
        """
        This function does similar with self.evaluate_basis(x), but will
        return orthogonal basis values (with weight 1).
        """
        normalizer = [np.sqrt((2 * k + 1) / 2) for k in range(1, self.order + 1)]
        return self.evaluate_basis(x) @ normalizer


class ChebyshevBasis(AbstractBasis):
    """
    One dimensional Chebyshev polynomials of the first kind basis
    - [T_0(x), T_1(x), ..., T_order(x)].
    Note that x should be within interval [-1, 1]
    """

    def __init__(self, order):
        self.order = order
        self._dim_basis = order + 1  # T_0, T_1, ..., T_order

    def evaluate_basis(self, x):
        x = np.array(x, ndmin=1)
        n_points = x.shape[0]

        B = np.zeros((n_points, self._dim_basis))

        for i in range(self._dim_basis):
            c = np.zeros(i+1)
            c[-1] = 1.0
            B[:, i] = chebyshev.chebval(x, c)

        return B

    def num_basis(self):
        return self._dim_basis

    def HBasis(self, x: np.ndarray) -> np.ndarray:
        """
        Chebyshev polynomials without concerning normalizers
        """
        return self.evaluate_basis(x)

